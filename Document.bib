@IEEEtranBSTCTL{IEEEexample:BSTcontrol,
CTLuse_forced_etal       = "yes",
CTLmax_names_forced_etal = "3",
CTLnames_show_etal       = "1" 
}

// Article 1
@article{Caviglione2021 ,
language = {English},
copyright = {Compilation and indexing terms, Copyright 2023 Elsevier Inc.},
copyright = {Compendex},
title = {Kernel-level tracing for detecting stegomalware and covert channels in Linux environments},
journal = {Computer Networks},
author = {Caviglione, Luca and Mazurczyk, Wojciech and Repetto, Matteo and Schaffhauser, Andreas and Zuppelli, Marco},
volume = {191},
year = {2021},
issn = {13891286},
abstract = {Modern malware is becoming hard to spot since attackers are increasingly adopting new techniques to elude signature- and rule-based detection mechanisms. Among the others, steganography and information hiding can be used to bypass security frameworks searching for suspicious communications between processes or exfiltration attempts through covert channels. Since the array of potential carriers is very large (e.g., information can be hidden in hardware resources, various multimedia files or network flows), detecting this class of threats is a scarcely generalizable process and gathering multiple behavioral information is time-consuming, lacks scalability, and could lead to performance degradation. In this paper, we leverage the extended Berkeley Packet Filter (eBPF), which is a recent code augmentation feature provided by the Linux kernel, for programmatically tracing and monitoring the behavior of software processes in a very efficient way. To prove the flexibility of the approach, we investigate two realistic use cases implementing different attack mechanisms, i.e., two processes colluding via the alteration of the file system and hidden network communication attempts nested within IPv6 traffic flows. Our results show that even simple eBPF programs can provide useful data for the detection of anomalies, with a minimal overhead. Furthermore, the flexibility to develop and run such programs allows to extract relevant features that could be used for the creation of datasets for feeding security frameworks exploiting AI.<br/> &copy; 2021},
key = {Linux},
keywords = {Multimedia systems;Malware;},
note = {Berkeley packet filters;Covert channels;Detection;Extended berkeley packet filter;Linux environment;Malwares;Security frameworks;Signature based detections;Stegomalware;Syscall and network tracing;},
URL = {http://dx.doi.org/10.1016/j.comnet.2021.108010},
} 


// Article 2
@article{Nemati2022 ,
language = {English},
copyright = {Copyright 2022, The Institution of Engineering and Technology},
title = {Critical Path Analysis through Hierarchical Distributed Virtualized Environments Using Host Kernel Tracing},
journal = {IEEE Transactions on Cloud Computing},
journal = {IEEE Trans. Cloud Comput. (USA)},
author = {Nemati, H. and Tetreault, F. and Puncher, J. and Dagenais, M.},
volume = { 10},
number = { 2},
year = {2022//},
pages = {774 - 91},
issn = {2168-7161},
address = {USA},
abstract = {The dynamic nature of applications in Virtual Machines (VMs) and the increasing demand for virtualized systems make the analysis of dynamic environments critical to achieve efficient operation of such complex distributed systems. In this article, we propose a precise host-based tracing and analysis method to retrieve execution flows, and dependency flows from virtualized environments, regardless of the level of nested virtualization. Given a host operating system level trace, the Any-Level vCPU Detection (ASD) algorithm and Guest Thread-state Analysis (GTA) algorithm detect the different states of vCPUs and threads for arbitrary nesting depths. Then, the Execution-graph Construction (HEC) algorithm extracts the waiting / wake-up dependencies chains out of the running processes across VMs, for any level of virtualization in a transparent manner. The process dependency graph, vCPU state, and VM process state are displayed in an interactive trace viewer, Trace Compass, for further inspection. Our proposed VM trace analysis algorithms have been open-sourced for further enhancements and collaborative research and development. Our new techniques were evaluated with workloads generated using several well-known server applications (e.g., Hadoop, Apache, MySQL, Linux apt-get, and IMS network). The proposed approaches are based on host hypervisor tracing, which brings a lower tracing overhead (around 1 percent), is easier to deploy, and presents fewer security issues as compared to other approaches.},
keywords = {graph theory;microprocessor chips;multi-threading;operating system kernels;virtual machines;virtualisation;},
note = {nested virtualization;host operating system level trace;arbitrary nesting depths;process dependency graph;VM process state;interactive trace viewer;VM trace analysis algorithms;host hypervisor tracing;critical path Analysis;hierarchical distributed virtualized environments;host kernel tracing;virtual machines;dynamic environments;complex distributed systems;execution-graph construction algorithm;thread-state analysis algorithm;any-level vCPU detection algorithm;trace compass;guest thread-state analysis algorithm;waiting-wake-up dependencies;host-based tracing;},
URL = {http://dx.doi.org/10.1109/TCC.2019.2953258},
} 

// Article 3
@inproceedings{Thrivikraman2022 ,
language = {English},
copyright = {Compilation and indexing terms, Copyright 2023 Elsevier Inc.},
copyright = {Compendex},
title = {Misertrace: Kernel-level request tracing for microservice visibility},
journal = {ICPE 2022 - Companion of the 2022 ACM/SPEC International Conference on Performance Engineering},
author = {Thrivikraman, V. and Dixit, Vishnu R. and Nikhil Ram, S. and Gowda, Vikas K. and Vasudevan, Santhosh Kumar and Kalambur, Subramaniam},
year = {2022},
pages = {77 - 80},
address = {Virtual, Online, China},
abstract = {<div data-language="eng" data-ev-field="abstract">With the evolution of microservice applications, the underlying architectures have become increasingly complex compared to their monolith counterparts. This mainly brings in the challenge of observability. By providing a deeper understanding into the functioning of distributed applications, observability enables improving the performance of the system by obtaining a view of the bottlenecks in the implementation. The observability provided by currently existing tools that perform dynamic tracing on distributed applications is limited to the user-space and requires the application to be instrumented to track request flows. In this paper, we present a new open-source framework MiSeRTrace that can trace the end-to-end path of requests entering a microservice application at the kernel space without requiring instrumentation or modification of the application. Observability at the comprehensiveness of the kernel space allows breaking down of various steps in activities such as network transfers and IO tasks, thus enabling root cause based performance analysis and accurate identification of hotspots. MiSeRTrace supports tracing user-enabled kernel events provided by frameworks such as bpftrace or ftrace and isolates kernel activity associated with each application request with minimal overheads. We then demonstrate the working of the solution with results on a benchmark microservice application.<br/></div> &copy; 2022 ACM.},
key = {Observability},
keywords = {Benchmarking;},
note = {Distributed applications;Kernel space;Kernel tracing;Microservice;Misertrace;Performance;Request tracing;State models;Thread state model;User spaces;},
URL = {http://dx.doi.org/10.1145/3491204.3527462},
} 


// Article 4
@article{Giraldeau2016 ,
language = {English},
copyright = {Copyright 2016, The Institution of Engineering and Technology},
title = {Wait Analysis of Distributed Systems Using Kernel Tracing},
journal = {IEEE Transactions on Parallel and Distributed Systems},
journal = {IEEE Trans. Parallel Distrib. Syst. (USA)},
author = {Giraldeau, F. and Dagenais, M.},
volume = { 27},
number = { 8},
year = {2016/08/},
pages = {2450 - 61},
issn = {1045-9219},
address = {USA},
abstract = {We propose a new class of profiler for distributed and heterogeneous systems. In these systems, a task may wait for the result of another task, either locally or remotely. Such wait dependencies are invisible to instruction profilers. We propose a host-based, precise method to recover recursively wait causes across machines, using blocking as the fundamental mechanism to detect changes in the control flow. It relies solely on operating system events, namely scheduling, interrupts and network events. It is therefore capable of observing kernel threads interactions and achieves user-space runtime independence. Given a task, the algorithm computes its active path from the trace, which is presented in an interactive viewer for inspection. We validated our new method with workloads representing major architecture and operating conditions found in distributed programs. We then used our method to analyze the execution behavior of five different distributed systems. We found that the worst case tracing overhead for a distributed application is 18 percent and that the typical average overhead is about 5 percent. The analysis implementation has linear runtime according to the trace size.},
keywords = {distributed processing;operating systems (computers);},
note = {wait analysis;distributed systems;kernel tracing;profiler class;heterogeneous systems;host-based method;control flow;operating system events;kernel threads interactions;user-space runtime independence;interactive viewer;distributed programs;execution behavior analysis;trace size;},
URL = {http://dx.doi.org/10.1109/TPDS.2015.2488629},
} 

// Article 5
@article{zayour2013much,
  title={How much integrated development environments (ides) improve productivity?},
  author={Zayour, Iyad and Hajjdiab, Hassan},
  journal={J. Softw.},
  volume={8},
  number={10},
  pages={2425--2431},
  year={2013}
}


// Article 6
@unpublished{Tan2023 ,
language = {English},
copyright = {Compilation and indexing terms, Copyright 2023 Elsevier Inc.},
copyright = {Compendex},
title = {Visual Studio Code in Introductory Computer Science Course: An Experience Report},
journal = {arXiv},
author = {Tan, Jialiang and Chen, Yu and Jiao, Shuyin},
year = {2023},
issn = {23318422},
abstract = {<div data-language="eng" data-ev-field="abstract">Involving integrated development environments (IDEs) in introductory-level (CS1) programming courses is critical. However, it is difficult for instructors to find a suitable IDE that is beginner friendly and supports strong functionality. In this paper, we report the experience of using Visual Studio Code (VS Code) in a CS1 programming course. We describe our motivation for choosing VS Code and how we introduce it to students. We create comprehensive guidance with hierarchical indexing to help students with diverse programming backgrounds. We perform an experimental evaluation of students&rsquo; programming experience of using VS Code and validate the VS Code together with guidance as a promising solution for CS1 programming courses.<br/></div> Copyright &copy; 2023, The Authors. All rights reserved.},
key = {Students},
keywords = {Curricula;Education computing;Studios;},
note = {Computer Science course;Diverse Programming;Experience report;Experimental evaluation;Hierarchical indexing;Integrated development environment;Introductory computer science;Programming course;Programming experience;Visual studios;},
URL = {http://dx.doi.org/10.48550/arXiv.2303.10174},
} 

// Article 7
@inproceedings{Bunder2019,
  title={Decoupling Language and Editor-The Impact of the Language Server Protocol on Textual Domain-Specific Languages.},
  author={B{\"u}nder, Hendrik},
  booktitle={MODELSWARD},
  pages={129--140},
  year={2019}
}

// Article 8
@inproceedings{Keidel2016,
  title={The IDE portability problem and its solution in Monto},
  author={Keidel, Sven and Pfeiffer, Wulf and Erdweg, Sebastian},
  booktitle={Proceedings of the 2016 ACM SIGPLAN International Conference on Software Language Engineering},
  pages={152--162},
  year={2016}
}

// Article 9
@article{Marr2017,
  title={A concurrency-agnostic protocol for multi-paradigm concurrent debugging tools},
  author={Marr, Stefan and Torres Lopez, Carmen and Aumayr, Dominik and Gonzalez Boix, Elisa and M{\"o}ssenb{\"o}ck, Hanspeter},
  journal={ACM SIGPLAN Notices},
  volume={52},
  number={11},
  pages={3--14},
  year={2017},
  publisher={ACM New York, NY, USA}
}

// Article 10
@article{enet2023,
  TITLE = {{Protocol-Based Interactive Debugging for Domain-Specific Languages}},
  AUTHOR = {Enet, Josselin and Bousse, Erwan and Tisi, Massimo and Suny{\'e}, Gerson},
  URL = {https://hal.science/hal-04124727},
  JOURNAL = {{The Journal of Object Technology}},
  HAL_LOCAL_REFERENCE = {19th European Conference on Modelling Foundations and Applications (ECMFA 2023)},
  PUBLISHER = {{Chair of Software Engineering}},
  VOLUME = {22},
  NUMBER = {2},
  YEAR = {2023},
  KEYWORDS = {Domain-specific languages ; Debugging ; Language tooling},
  PDF = {https://hal.science/hal-04124727/file/main.pdf},
  HAL_ID = {hal-04124727},
  HAL_VERSION = {v1},
}

// Article 11
@article{mungoli2023scalable,
  title={Scalable, Distributed AI Frameworks: Leveraging Cloud Computing for Enhanced Deep Learning Performance and Efficiency},
  author={Mungoli, Neelesh},
  journal={arXiv preprint arXiv:2304.13738},
  year={2023}
}

// Article 12
@article{li2023sustainable,
  title={Sustainable HPC: Modeling, Characterization, and Implications of Carbon Footprint in Modern HPC Systems},
  author={Li, Baolin and Samsi, Siddharth and Gadepally, Vijay and Tiwari, Devesh},
  journal={arXiv preprint arXiv:2306.13177},
  year={2023}
}

// Article 13
@inproceedings{li2023analyzing,
  title={Analyzing Resource Utilization in an HPC System: A Case Study of NERSC’s Perlmutter},
  author={Li, Jie and Michelogiannakis, George and Cook, Brandon and Cooray, Dulanya and Chen, Yong},
  booktitle={International Conference on High Performance Computing},
  pages={297--316},
  year={2023},
  organization={Springer}
}

// Article 14
@INPROCEEDINGS{Dhakate2015,
  author={Dhakate, Suchit and Godbole, Anand},
  booktitle={2015 Annual IEEE India Conference (INDICON)}, 
  title={Distributed cloud monitoring using Docker as next generation container virtualization technology}, 
  year={2015},
  volume={},
  number={},
  pages={1-5},
  doi={10.1109/INDICON.2015.7443771}
}

// Article 15 

@inproceedings{beermann2020implementation,
  title={Implementation of ATLAS Distributed Computing monitoring dashboards using InfluxDB and Grafana},
  author={Beermann, Thomas and Alekseev, Aleksandr and Baberis, Dario and Cr{\'e}p{\'e}-Renaudin, Sabine and Elmsheuser, Johannes and Glushkov, Ivan and Svatos, Michal and Vartapetian, Armen and Vokac, Petr and Wolters, Helmut},
  booktitle={EPJ Web of Conferences},
  volume={245},
  pages={03031},
  year={2020},
  organization={EDP Sciences}
}

// Article 16

@INPROCEEDINGS{Sukhija2019,
  author={Sukhija, Nitin and Bautista, Elizabeth},
  booktitle={2019 IEEE SmartWorld, Ubiquitous Intelligence & Computing, Advanced & Trusted Computing, Scalable Computing & Communications, Cloud & Big Data Computing, Internet of People and Smart City Innovation (SmartWorld/SCALCOM/UIC/ATC/CBDCom/IOP/SCI)}, 
  title={Towards a Framework for Monitoring and Analyzing High Performance Computing Environments Using Kubernetes and Prometheus}, 
  year={2019},
  volume={},
  number={},
  pages={257-262},
  doi={10.1109/SmartWorld-UIC-ATC-SCALCOM-IOP-SCI.2019.00087}
}


// Article 17
@article{salloum2016big,
  title={Big data analytics on Apache Spark},
  author={Salloum, Salman and Dautov, Ruslan and Chen, Xiaojun and Peng, Patrick Xiaogang and Huang, Joshua Zhexue},
  journal={International Journal of Data Science and Analytics},
  volume={1},
  pages={145--164},
  year={2016},
  publisher={Springer}
}

// Article 18
@mastersthesis{Martin2018,
    month = {August},
    title = {Analyse d{\'e}taill{\'e}e de trace en d{\'e}pit d'{\'e}v{\'e}nements manquants},
    school = {{\'E}cole Polytechnique de Montr{\'e}al},
    author = {Marie Martin},
    year = {2018},
    url = {https://publications.polymtl.ca/3248/},
    abstract = {R{\'E}SUM{\'E}: Le tra{\c c}age offre une compr{\'e}hension d{\'e}taill{\'e}e du fonctionnement d'un syst{\`e}me ou d'une application, mais la simple {\'e}tude d'une trace ne permet pas d'exploiter tout le potentiel des informations contenues dans les {\'e}v{\'e}nements qui la constituent. C'est pour cela que les sp{\'e}cialistes des syst{\`e}mes distribu{\'e}s et de l'analyse de performance d{\'e}veloppent des analyses complexes, qui sont ensuite int{\'e}gr{\'e}es aux outils de visualisation de traces. Ces outils supposent que le processus de tra{\c c}age s'est d{\'e}roul{\'e} sans erreurs. N{\'e}anmoins, il arrive que des {\'e}v{\'e}nements soient perdus. Ceci survient lorsque les structures de donn{\'e}es (souvent des tampons circulaires) devant stocker les {\'e}v{\'e}nements avant leur {\'e}criture dans la trace sur disque sont pleins, alors que d'autres {\'e}v{\'e}nements sont g{\'e}n{\'e}r{\'e}s. Pour {\'e}viter de bloquer le syst{\`e}me, le traceur doit jeter les {\'e}v{\'e}nements les plus r{\'e}cents, ou {\'e}craser les plus anciens. Il n'existe pas de m{\'e}canisme pour g{\'e}rer ce cas lors de l'analyse de trace, ce qui cr{\'e}e des incoh{\'e}rences dans les r{\'e}sultats sans que l'utilisateur en soit notifi{\'e}. L'objectif de cette recherche est donc d'{\'e}tudier le probl{\`e}me des {\'e}v{\'e}nements perdus dans une trace lors de son analyse, et d'apporter des solutions permettant d'indiquer les incoh{\'e}rences et d'y rem{\'e}dier. Notre hypoth{\`e}se {\'e}tait que les {\'e}v{\'e}nements pr{\'e}sents dans la trace contiennent suffisament d'information pour pouvoir d{\'e}tecter un changement d'{\'e}tat qui n'aurait pas d{\^u} avoir lieu, et pour compl{\'e}ter la chronologie manquante. Pour cela, nous avons utilis{\'e} des machines {\`a} {\'e}tats finis, puisque ce formalisme de repr{\'e}sentation permet de mod{\'e}liser le syst{\`e}me {\'e}tudi{\'e}, en d{\'e}finissant la fa{\c c}on dont les {\'e}v{\'e}nements g{\'e}n{\`e}rent des changements d'{\'e}tats. Ces machines {\`a} {\'e}tats poss{\`e}dent des propri{\'e}t{\'e}s qui peuvent {\^e}tre exploit{\'e}es pour retrouver les informations perdues.  ABSTRACT: With tracing, a lot of information can be gathered from a system or an application. This information needs to be exploited in order to provide a useful insight into the operation of our system. Experts develop complex trace analyses, but it does not take into account the fact that some events may have been lost during the tracing process, due to a much bigger flow of generated events than the capacity of writing into the trace. Therefore, the results may contain some inconsistencies. Our objective is to deal with these lost events at the trace analysis level. Using finite state machines to model the system, we are able to check the certainty of each new state. If no transition can be triggered from the current state, we check if one could be triggered from another state. By doing so, we can find inconsistencies. Then, we can correct these by looking for the sequence of transitions between the last coherent state and the incoherent one. Dijkstra's shortest-path algorithm is applied, with frequencies used as weights for the transitions. Once the transitions have been inferred, we can deduce the related lost events and their content. The proposed solution has been implemented in Trace Compass, a trace visualisation tool. The new information is displayed on the view representing the results of the analysis. It allowed us to apply our method to a few usecases, thus demonstrating its usefulness. The accuracy of the recovery phase is 53\%. The overhead of the detection phase is reasonable for small traces, but can increase rapidly for bigger ones. However, the inference phase does not cost too much in any case.}
}

// Article 19 et 24
@article{matloff2011programming,
  title={Programming on parallel machines},
  author={Matloff, Norm},
  journal={University of California, Davis},
  volume={39319},
  year={2011}
}

// Article 20 
@article{denys2023distributed,
  title={Distributed computation of the critical path from execution traces},
  author={Denys, Pierre-Fr{\'e}d{\'e}rick and Fournier, Quentin and Dagenais, Michel R},
  journal={Software: Practice and Experience},
  year={2023},
  publisher={Wiley Online Library}
}

// Article 21
@misc{besseling2022trace,
  title={Trace Visualization with Java Pathfinder using Theia Trace Viewer},
  author={Besseling, Johan},
  year={2022}
}

// Article 22

@article{janes2022open,
  title={Open Tracing Tools: Overview and Critical Comparison},
  author={Janes, Andrea and Li, Xiaozhou and Lenarduzzi, Valentina},
  journal={arXiv preprint arXiv:2207.06875},
  year={2022}
}

// Article 23
@phdthesis{reumont2015methodes,
  title={M{\'e}thodes efficaces de parall{\'e}lisation de l'analyse de traces noyau},
  author={Reumont-Locke, Fabien},
  year={2015},
  school={{\'E}cole Polytechnique de Montr{\'e}al}
}

// Article 25
@misc{Logz.io_prometheus_2023, 
  url={https://logz.io/blog/prometheus-architecture-at-scale/#:~:text=The%20most%20straightforward%20way%20to,%3A%20hierarchical%20and%20cross%2Dservice.}, 
  journal={Logz.io}, 
  year={2023}, 
  month={Oct}
} 

// Article 26

@misc{Nagios2019, 
    url={https://assets.nagios.com/downloads/general/docs/Monitoring_Architecture_Solutions_For_Large_Organizations.pdf}, 
    journal={Nagios - monitoring architecture solutions for large organizations},
    year={2019} 
} 


// Article 27
@inproceedings{desnoyers2006lttng,
  title={The lttng tracer: A low impact performance and behavior monitor for gnu/linux},
  author={Desnoyers, Mathieu and Dagenais, Michel R},
  booktitle={OLS (Ottawa Linux Symposium)},
  volume={2006},
  pages={209--224},
  year={2006},
  organization={Citeseer}
}

// Article 28
@article{adhianto2010hpctoolkit,
  title={HPCToolkit: Tools for performance analysis of optimized parallel programs},
  author={Adhianto, Laksono and Banerjee, Sinchan and Fagan, Mike and Krentel, Mark and Marin, Gabriel and Mellor-Crummey, John and Tallent, Nathan R},
  journal={Concurrency and Computation: Practice and Experience},
  volume={22},
  number={6},
  pages={685--701},
  year={2010},
  publisher={Wiley Online Library}
}

// Article 29
@misc{kernelPerfWiki,
author      = {},
title       = {{P}erf {W}iki --- perf.wiki.kernel.org},
howpublished= {\url{https://perf.wiki.kernel.org/index.php/Main_Page}},
year        = {2023},
note        = {[Accessed 16-10-2023]},
}

// Article 30
@inproceedings{ilsche2015combining,
  title={Combining instrumentation and sampling for trace-based application performance analysis},
  author={Ilsche, Thomas and Schuchart, Joseph and Sch{\"o}ne, Robert and Hackenberg, Daniel},
  booktitle={Tools for High Performance Computing 2014: Proceedings of the 8th International Workshop on Parallel Tools for High Performance Computing, October 2014, HLRS, Stuttgart, Germany},
  pages={123--136},
  year={2015},
  organization={Springer}
}

// Article 31
@misc{man7Perf,
	author = {},
	title = {perf\_event\_open(2) - {L}inux manual page --- man7.org},
	howpublished = {\url{https://man7.org/linux/man-pages/man2/perf_event_open.2.html}},
	year = {},
	note = {[Accessed 16-10-2023]},
}


// Article 32
@misc{sourceforgeAboutOProfile,
	author = {},
	title = {{A}bout {O}{P}rofile --- oprofile.sourceforge.io},
	howpublished = {\url{https://oprofile.sourceforge.io/about/}},
	year = {},
	note = {[Accessed 16-10-2023]},
}

// Article 33
@inproceedings{schone2014scalable,
  title={Scalable tools for non-intrusive performance debugging of parallel linux workloads},
  author={Sch{\"o}ne, Robert and Schuchart, Joseph and Ilsche, Thomas and Hackenberg, Daniel},
  year={2014},
  organization={Ottawa Linux Symposium Comittee}
}

// Article 34
@article{prieur2018r,
  title={R-SHT: A state history tree with R-Tree properties for analysis and visualization of highly parallel system traces},
  author={Prieur-Drevon, Loic and Beamonte, Rapha{\"e}l and Dagenais, Michel R},
  journal={Journal of Systems and Software},
  volume={135},
  pages={55--68},
  year={2018},
  publisher={Elsevier}
}

// Article 35
@article{chen2021distributed,
  title={Distributed architecture for an integrated development environment, large trace analysis, and visualization},
  author={Chen Kuang Piao, Yonni and Ezzati-Jivan, Naser and Dagenais, Michel R},
  journal={Sensors},
  volume={21},
  number={16},
  pages={5560},
  year={2021},
  publisher={MDPI}
}


// Article 36

@misc{apptainerHome,
	author = {},
	title = {{H}ome --- apptainer.org},
	howpublished = {\url{https://apptainer.org/}},
	year = {},
	note = {[Accessed 16-10-2023]},
}

// Article 37

@misc{ansibleAnsibleSimple,
	author = {Ansible, Red Hat},
	title = {{A}nsible is {S}imple {I}{T} {A}utomation --- ansible.com},
	howpublished = {\url{https://www.ansible.com/}},
	year = {},
	note = {[Accessed 16-10-2023]},
}

// Article 38

@book{gregg2011dtrace,
  title={DTrace: Dynamic Tracing in Oracle Solaris, Mac OS X, and FreeBSD},
  author={Gregg, Brendan and Mauro, Jim},
  year={2011},
  publisher={Prentice Hall Professional}
}

@manual{Ericsson_TSP_OPENAPI,
  author       = {Ericsson},
  title        = {Trace server protocol openapi specification},
  url          = {https://raw.githubusercontent.com/theia-ide/trace-server-protocol/master/API.yaml}
}

@misc{github_ericsson_TSP,
  author       = {Ericsson},
  howpublished = {\url{https://raw.githubusercontent.com/theia-ide/trace-server-protocol/master/API.yaml}},
  title        = {Trace server protocol}
}

@inbook{
  Foundation, 
  place={Toulouse}, 
  title={}, 
  author={Foundation, Eclipse},
  
} 

@conference{theia_2017,
  author          = {Sven Efftinge, Anton Kosyakov},
  title           = {Theia - One IDE Framework For Desktop \& Cloud},
  month           = {June},
  booktitle       = {EclipseCon France 2017},
  address         = {Toulouse, France},
  year            = {2017}
}

@INPROCEEDINGS{Na_2020,
  author={Na, Heechang and You, Zhi-Qiang and Baer, Troy and Oottikkal, Shameema and Dockendorf, Trey and Brozell, Scott},
  booktitle={2020 IEEE/ACM International Workshop on HPC User Support Tools (HUST) and Workshop on Programming and Performance Visualization Tools (ProTools)}, 
  title={HPC Software Tracking Strategies for a Diverse Workload}, 
  year={2020},
  volume={},
  number={},
  pages={1-9},
  doi={10.1109/HUSTProtools51951.2020.00008}
}
