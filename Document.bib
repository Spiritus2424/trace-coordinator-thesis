@ieeetranbstctl{IEEEexample:BSTcontrol,
  ctluse_forced_etal       = {yes},
  ctlmax_names_forced_etal = {3},
  ctlnames_show_etal       = {1}
}

// Article 1
@article{Caviglione2021,
  language  = {English},
  copyright = {Compilation and indexing terms, Copyright 2023 Elsevier Inc.},
  copyright = {Compendex},
  title     = {Kernel-level tracing for detecting stegomalware and covert channels in Linux environments},
  journal   = {Computer Networks},
  author    = {Caviglione, Luca and Mazurczyk, Wojciech and Repetto, Matteo and Schaffhauser, Andreas and Zuppelli, Marco},
  volume    = {191},
  year      = {2021},
  issn      = {13891286},
  abstract  = {Modern malware is becoming hard to spot since attackers are increasingly adopting new techniques to elude signature- and rule-based detection mechanisms. Among the others, steganography and information hiding can be used to bypass security frameworks searching for suspicious communications between processes or exfiltration attempts through covert channels. Since the array of potential carriers is very large (e.g., information can be hidden in hardware resources, various multimedia files or network flows), detecting this class of threats is a scarcely generalizable process and gathering multiple behavioral information is time-consuming, lacks scalability, and could lead to performance degradation. In this paper, we leverage the extended Berkeley Packet Filter (eBPF), which is a recent code augmentation feature provided by the Linux kernel, for programmatically tracing and monitoring the behavior of software processes in a very efficient way. To prove the flexibility of the approach, we investigate two realistic use cases implementing different attack mechanisms, i.e., two processes colluding via the alteration of the file system and hidden network communication attempts nested within IPv6 traffic flows. Our results show that even simple eBPF programs can provide useful data for the detection of anomalies, with a minimal overhead. Furthermore, the flexibility to develop and run such programs allows to extract relevant features that could be used for the creation of datasets for feeding security frameworks exploiting AI.<br/> &copy; 2021},
  key       = {Linux},
  keywords  = {Multimedia systems;Malware;},
  note      = {Berkeley packet filters;Covert channels;Detection;Extended berkeley packet filter;Linux environment;Malwares;Security frameworks;Signature based detections;Stegomalware;Syscall and network tracing;},
  url       = {http://dx.doi.org/10.1016/j.comnet.2021.108010}
} 


// Article 2
@article{Nemati2022,
  language  = {English},
  copyright = {Copyright 2022, The Institution of Engineering and Technology},
  title     = {Critical Path Analysis through Hierarchical Distributed Virtualized Environments Using Host Kernel Tracing},
  journal   = {IEEE Transactions on Cloud Computing},
  journal   = {IEEE Trans. Cloud Comput. (USA)},
  author    = {Nemati, H. and Tetreault, F. and Puncher, J. and Dagenais, M.},
  volume    = { 10},
  number    = { 2},
  year      = {2022//},
  pages     = {774 - 91},
  issn      = {2168-7161},
  address   = {USA},
  abstract  = {The dynamic nature of applications in Virtual Machines (VMs) and the increasing demand for virtualized systems make the analysis of dynamic environments critical to achieve efficient operation of such complex distributed systems. In this article, we propose a precise host-based tracing and analysis method to retrieve execution flows, and dependency flows from virtualized environments, regardless of the level of nested virtualization. Given a host operating system level trace, the Any-Level vCPU Detection (ASD) algorithm and Guest Thread-state Analysis (GTA) algorithm detect the different states of vCPUs and threads for arbitrary nesting depths. Then, the Execution-graph Construction (HEC) algorithm extracts the waiting / wake-up dependencies chains out of the running processes across VMs, for any level of virtualization in a transparent manner. The process dependency graph, vCPU state, and VM process state are displayed in an interactive trace viewer, Trace Compass, for further inspection. Our proposed VM trace analysis algorithms have been open-sourced for further enhancements and collaborative research and development. Our new techniques were evaluated with workloads generated using several well-known server applications (e.g., Hadoop, Apache, MySQL, Linux apt-get, and IMS network). The proposed approaches are based on host hypervisor tracing, which brings a lower tracing overhead (around 1 percent), is easier to deploy, and presents fewer security issues as compared to other approaches.},
  keywords  = {graph theory;microprocessor chips;multi-threading;operating system kernels;virtual machines;virtualisation;},
  note      = {nested virtualization;host operating system level trace;arbitrary nesting depths;process dependency graph;VM process state;interactive trace viewer;VM trace analysis algorithms;host hypervisor tracing;critical path Analysis;hierarchical distributed virtualized environments;host kernel tracing;virtual machines;dynamic environments;complex distributed systems;execution-graph construction algorithm;thread-state analysis algorithm;any-level vCPU detection algorithm;trace compass;guest thread-state analysis algorithm;waiting-wake-up dependencies;host-based tracing;},
  url       = {http://dx.doi.org/10.1109/TCC.2019.2953258}
} 

// Article 3
@inproceedings{Thrivikraman2022,
  language  = {English},
  copyright = {Compilation and indexing terms, Copyright 2023 Elsevier Inc.},
  copyright = {Compendex},
  title     = {Misertrace: Kernel-level request tracing for microservice visibility},
  journal   = {ICPE 2022 - Companion of the 2022 ACM/SPEC International Conference on Performance Engineering},
  author    = {Thrivikraman, V. and Dixit, Vishnu R. and Nikhil Ram, S. and Gowda, Vikas K. and Vasudevan, Santhosh Kumar and Kalambur, Subramaniam},
  year      = {2022},
  pages     = {77 - 80},
  address   = {Virtual, Online, China},
  abstract  = {<div data-language="eng" data-ev-field="abstract">With the evolution of microservice applications, the underlying architectures have become increasingly complex compared to their monolith counterparts. This mainly brings in the challenge of observability. By providing a deeper understanding into the functioning of distributed applications, observability enables improving the performance of the system by obtaining a view of the bottlenecks in the implementation. The observability provided by currently existing tools that perform dynamic tracing on distributed applications is limited to the user-space and requires the application to be instrumented to track request flows. In this paper, we present a new open-source framework MiSeRTrace that can trace the end-to-end path of requests entering a microservice application at the kernel space without requiring instrumentation or modification of the application. Observability at the comprehensiveness of the kernel space allows breaking down of various steps in activities such as network transfers and IO tasks, thus enabling root cause based performance analysis and accurate identification of hotspots. MiSeRTrace supports tracing user-enabled kernel events provided by frameworks such as bpftrace or ftrace and isolates kernel activity associated with each application request with minimal overheads. We then demonstrate the working of the solution with results on a benchmark microservice application.<br/></div> &copy; 2022 ACM.},
  key       = {Observability},
  keywords  = {Benchmarking;},
  note      = {Distributed applications;Kernel space;Kernel tracing;Microservice;Misertrace;Performance;Request tracing;State models;Thread state model;User spaces;},
  url       = {http://dx.doi.org/10.1145/3491204.3527462}
} 


// Article 4
@article{Giraldeau2016,
  language  = {English},
  copyright = {Copyright 2016, The Institution of Engineering and Technology},
  title     = {Wait Analysis of Distributed Systems Using Kernel Tracing},
  journal   = {IEEE Transactions on Parallel and Distributed Systems},
  journal   = {IEEE Trans. Parallel Distrib. Syst. (USA)},
  author    = {Giraldeau, F. and Dagenais, M.},
  volume    = { 27},
  number    = { 8},
  year      = {2016/08/},
  pages     = {2450 - 61},
  issn      = {1045-9219},
  address   = {USA},
  abstract  = {We propose a new class of profiler for distributed and heterogeneous systems. In these systems, a task may wait for the result of another task, either locally or remotely. Such wait dependencies are invisible to instruction profilers. We propose a host-based, precise method to recover recursively wait causes across machines, using blocking as the fundamental mechanism to detect changes in the control flow. It relies solely on operating system events, namely scheduling, interrupts and network events. It is therefore capable of observing kernel threads interactions and achieves user-space runtime independence. Given a task, the algorithm computes its active path from the trace, which is presented in an interactive viewer for inspection. We validated our new method with workloads representing major architecture and operating conditions found in distributed programs. We then used our method to analyze the execution behavior of five different distributed systems. We found that the worst case tracing overhead for a distributed application is 18 percent and that the typical average overhead is about 5 percent. The analysis implementation has linear runtime according to the trace size.},
  keywords  = {distributed processing;operating systems (computers);},
  note      = {wait analysis;distributed systems;kernel tracing;profiler class;heterogeneous systems;host-based method;control flow;operating system events;kernel threads interactions;user-space runtime independence;interactive viewer;distributed programs;execution behavior analysis;trace size;},
  url       = {http://dx.doi.org/10.1109/TPDS.2015.2488629}
} 

// Article 5
@article{zayour2013much,
  title   = {How much integrated development environments (ides) improve productivity?},
  author  = {Zayour, Iyad and Hajjdiab, Hassan},
  journal = {J. Softw.},
  volume  = {8},
  number  = {10},
  pages   = {2425--2431},
  year    = {2013}
}


// Article 6
@unpublished{Tan2023,
  language  = {English},
  copyright = {Compilation and indexing terms, Copyright 2023 Elsevier Inc.},
  copyright = {Compendex},
  title     = {Visual Studio Code in Introductory Computer Science Course: An Experience Report},
  journal   = {arXiv},
  author    = {Tan, Jialiang and Chen, Yu and Jiao, Shuyin},
  year      = {2023},
  issn      = {23318422},
  abstract  = {<div data-language="eng" data-ev-field="abstract">Involving integrated development environments (IDEs) in introductory-level (CS1) programming courses is critical. However, it is difficult for instructors to find a suitable IDE that is beginner friendly and supports strong functionality. In this paper, we report the experience of using Visual Studio Code (VS Code) in a CS1 programming course. We describe our motivation for choosing VS Code and how we introduce it to students. We create comprehensive guidance with hierarchical indexing to help students with diverse programming backgrounds. We perform an experimental evaluation of students&rsquo; programming experience of using VS Code and validate the VS Code together with guidance as a promising solution for CS1 programming courses.<br/></div> Copyright &copy; 2023, The Authors. All rights reserved.},
  key       = {Students},
  keywords  = {Curricula;Education computing;Studios;},
  note      = {Computer Science course;Diverse Programming;Experience report;Experimental evaluation;Hierarchical indexing;Integrated development environment;Introductory computer science;Programming course;Programming experience;Visual studios;},
  url       = {http://dx.doi.org/10.48550/arXiv.2303.10174}
} 

// Article 7
@inproceedings{Bunder2019,
  title     = {Decoupling Language and Editor-The Impact of the Language Server Protocol on Textual Domain-Specific Languages.},
  author    = {B{\"u}nder, Hendrik},
  booktitle = {MODELSWARD},
  pages     = {129--140},
  year      = {2019}
}

// Article 8
@inproceedings{Keidel2016,
  title     = {The IDE portability problem and its solution in Monto},
  author    = {Keidel, Sven and Pfeiffer, Wulf and Erdweg, Sebastian},
  booktitle = {Proceedings of the 2016 ACM SIGPLAN International Conference on Software Language Engineering},
  pages     = {152--162},
  year      = {2016}
}

// Article 9
@article{Marr2017,
  title     = {A concurrency-agnostic protocol for multi-paradigm concurrent debugging tools},
  author    = {Marr, Stefan and Torres Lopez, Carmen and Aumayr, Dominik and Gonzalez Boix, Elisa and M{\"o}ssenb{\"o}ck, Hanspeter},
  journal   = {ACM SIGPLAN Notices},
  volume    = {52},
  number    = {11},
  pages     = {3--14},
  year      = {2017},
  publisher = {ACM New York, NY, USA}
}

// Article 10
@article{enet2023,
  title               = {{Protocol-Based Interactive Debugging for Domain-Specific Languages}},
  author              = {Enet, Josselin and Bousse, Erwan and Tisi, Massimo and Suny{\'e}, Gerson},
  url                 = {https://hal.science/hal-04124727},
  journal             = {{The Journal of Object Technology}},
  hal_local_reference = {19th European Conference on Modelling Foundations and Applications (ECMFA 2023)},
  publisher           = {{Chair of Software Engineering}},
  volume              = {22},
  number              = {2},
  year                = {2023},
  keywords            = {Domain-specific languages ; Debugging ; Language tooling},
  pdf                 = {https://hal.science/hal-04124727/file/main.pdf},
  hal_id              = {hal-04124727},
  hal_version         = {v1}
}

// Article 11
@article{mungoli2023scalable,
  title   = {Scalable, Distributed AI Frameworks: Leveraging Cloud Computing for Enhanced Deep Learning Performance and Efficiency},
  author  = {Mungoli, Neelesh},
  journal = {arXiv preprint arXiv:2304.13738},
  year    = {2023}
}

// Article 12
@article{li2023sustainable,
  title   = {Sustainable HPC: Modeling, Characterization, and Implications of Carbon Footprint in Modern HPC Systems},
  author  = {Li, Baolin and Samsi, Siddharth and Gadepally, Vijay and Tiwari, Devesh},
  journal = {arXiv preprint arXiv:2306.13177},
  year    = {2023}
}

// Article 13
@inproceedings{li2023analyzing,
  title        = {Analyzing Resource Utilization in an HPC System: A Case Study of NERSC’s Perlmutter},
  author       = {Li, Jie and Michelogiannakis, George and Cook, Brandon and Cooray, Dulanya and Chen, Yong},
  booktitle    = {International Conference on High Performance Computing},
  pages        = {297--316},
  year         = {2023},
  organization = {Springer}
}

// Article 14
@inproceedings{Dhakate2015,
  author    = {Dhakate, Suchit and Godbole, Anand},
  booktitle = {2015 Annual IEEE India Conference (INDICON)},
  title     = {Distributed cloud monitoring using Docker as next generation container virtualization technology},
  year      = {2015},
  volume    = {},
  number    = {},
  pages     = {1-5},
  doi       = {10.1109/INDICON.2015.7443771}
}

// Article 15 

@inproceedings{beermann2020implementation,
  title        = {Implementation of ATLAS Distributed Computing monitoring dashboards using InfluxDB and Grafana},
  author       = {Beermann, Thomas and Alekseev, Aleksandr and Baberis, Dario and Cr{\'e}p{\'e}-Renaudin, Sabine and Elmsheuser, Johannes and Glushkov, Ivan and Svatos, Michal and Vartapetian, Armen and Vokac, Petr and Wolters, Helmut},
  booktitle    = {EPJ Web of Conferences},
  volume       = {245},
  pages        = {03031},
  year         = {2020},
  organization = {EDP Sciences}
}

// Article 16

@inproceedings{Sukhija2019,
  author    = {Sukhija, Nitin and Bautista, Elizabeth},
  booktitle = {2019 IEEE SmartWorld, Ubiquitous Intelligence & Computing, Advanced & Trusted Computing, Scalable Computing & Communications, Cloud & Big Data Computing, Internet of People and Smart City Innovation (SmartWorld/SCALCOM/UIC/ATC/CBDCom/IOP/SCI)},
  title     = {Towards a Framework for Monitoring and Analyzing High Performance Computing Environments Using Kubernetes and Prometheus},
  year      = {2019},
  volume    = {},
  number    = {},
  pages     = {257-262},
  doi       = {10.1109/SmartWorld-UIC-ATC-SCALCOM-IOP-SCI.2019.00087}
}


// Article 17
@article{salloum2016big,
  title     = {Big data analytics on Apache Spark},
  author    = {Salloum, Salman and Dautov, Ruslan and Chen, Xiaojun and Peng, Patrick Xiaogang and Huang, Joshua Zhexue},
  journal   = {International Journal of Data Science and Analytics},
  volume    = {1},
  pages     = {145--164},
  year      = {2016},
  publisher = {Springer}
}

// Article 18
@mastersthesis{Martin2018,
  month    = {August},
  title    = {Analyse d{\'e}taill{\'e}e de trace en d{\'e}pit d'{\'e}v{\'e}nements manquants},
  school   = {{\'E}cole Polytechnique de Montr{\'e}al},
  author   = {Marie Martin},
  year     = {2018},
  url      = {https://publications.polymtl.ca/3248/},
  abstract = {R{\'E}SUM{\'E}: Le tra{\c c}age offre une compr{\'e}hension d{\'e}taill{\'e}e du fonctionnement d'un syst{\`e}me ou d'une application, mais la simple {\'e}tude d'une trace ne permet pas d'exploiter tout le potentiel des informations contenues dans les {\'e}v{\'e}nements qui la constituent. C'est pour cela que les sp{\'e}cialistes des syst{\`e}mes distribu{\'e}s et de l'analyse de performance d{\'e}veloppent des analyses complexes, qui sont ensuite int{\'e}gr{\'e}es aux outils de visualisation de traces. Ces outils supposent que le processus de tra{\c c}age s'est d{\'e}roul{\'e} sans erreurs. N{\'e}anmoins, il arrive que des {\'e}v{\'e}nements soient perdus. Ceci survient lorsque les structures de donn{\'e}es (souvent des tampons circulaires) devant stocker les {\'e}v{\'e}nements avant leur {\'e}criture dans la trace sur disque sont pleins, alors que d'autres {\'e}v{\'e}nements sont g{\'e}n{\'e}r{\'e}s. Pour {\'e}viter de bloquer le syst{\`e}me, le traceur doit jeter les {\'e}v{\'e}nements les plus r{\'e}cents, ou {\'e}craser les plus anciens. Il n'existe pas de m{\'e}canisme pour g{\'e}rer ce cas lors de l'analyse de trace, ce qui cr{\'e}e des incoh{\'e}rences dans les r{\'e}sultats sans que l'utilisateur en soit notifi{\'e}. L'objectif de cette recherche est donc d'{\'e}tudier le probl{\`e}me des {\'e}v{\'e}nements perdus dans une trace lors de son analyse, et d'apporter des solutions permettant d'indiquer les incoh{\'e}rences et d'y rem{\'e}dier. Notre hypoth{\`e}se {\'e}tait que les {\'e}v{\'e}nements pr{\'e}sents dans la trace contiennent suffisament d'information pour pouvoir d{\'e}tecter un changement d'{\'e}tat qui n'aurait pas d{\^u} avoir lieu, et pour compl{\'e}ter la chronologie manquante. Pour cela, nous avons utilis{\'e} des machines {\`a} {\'e}tats finis, puisque ce formalisme de repr{\'e}sentation permet de mod{\'e}liser le syst{\`e}me {\'e}tudi{\'e}, en d{\'e}finissant la fa{\c c}on dont les {\'e}v{\'e}nements g{\'e}n{\`e}rent des changements d'{\'e}tats. Ces machines {\`a} {\'e}tats poss{\`e}dent des propri{\'e}t{\'e}s qui peuvent {\^e}tre exploit{\'e}es pour retrouver les informations perdues.  ABSTRACT: With tracing, a lot of information can be gathered from a system or an application. This information needs to be exploited in order to provide a useful insight into the operation of our system. Experts develop complex trace analyses, but it does not take into account the fact that some events may have been lost during the tracing process, due to a much bigger flow of generated events than the capacity of writing into the trace. Therefore, the results may contain some inconsistencies. Our objective is to deal with these lost events at the trace analysis level. Using finite state machines to model the system, we are able to check the certainty of each new state. If no transition can be triggered from the current state, we check if one could be triggered from another state. By doing so, we can find inconsistencies. Then, we can correct these by looking for the sequence of transitions between the last coherent state and the incoherent one. Dijkstra's shortest-path algorithm is applied, with frequencies used as weights for the transitions. Once the transitions have been inferred, we can deduce the related lost events and their content. The proposed solution has been implemented in Trace Compass, a trace visualisation tool. The new information is displayed on the view representing the results of the analysis. It allowed us to apply our method to a few usecases, thus demonstrating its usefulness. The accuracy of the recovery phase is 53\%. The overhead of the detection phase is reasonable for small traces, but can increase rapidly for bigger ones. However, the inference phase does not cost too much in any case.}
}

// Article 19 et 24
@article{matloff2011programming,
  title   = {Programming on parallel machines},
  author  = {Matloff, Norm},
  journal = {University of California, Davis},
  volume  = {39319},
  year    = {2011}
}

// Article 20 
@article{denys2023distributed,
  title     = {Distributed computation of the critical path from execution traces},
  author    = {Denys, Pierre-Fr{\'e}d{\'e}rick and Fournier, Quentin and Dagenais, Michel R},
  journal   = {Software: Practice and Experience},
  year      = {2023},
  publisher = {Wiley Online Library}
}

// Article 21
@misc{besseling2022trace,
  title  = {Trace Visualization with Java Pathfinder using Theia Trace Viewer},
  author = {Besseling, Johan},
  year   = {2022}
}

// Article 22

@article{janes2022open,
  title   = {Open Tracing Tools: Overview and Critical Comparison},
  author  = {Janes, Andrea and Li, Xiaozhou and Lenarduzzi, Valentina},
  journal = {arXiv preprint arXiv:2207.06875},
  year    = {2022}
}

// Article 23
@phdthesis{reumont2015methodes,
  title  = {M{\'e}thodes efficaces de parall{\'e}lisation de l'analyse de traces noyau},
  author = {Reumont-Locke, Fabien},
  year   = {2015},
  school = {{\'E}cole Polytechnique de Montr{\'e}al}
}

// Article 25
@misc{Logz.io_prometheus_2023,
  url     = {https://logz.io/blog/prometheus-architecture-at-scale/#:~:text=The%20most%20straightforward%20way%20to,%3A%20hierarchical%20and%20cross%2Dservice.},
  journal = {Logz.io},
  year    = {2023},
  month   = {Oct}
} 

// Article 26

@misc{Nagios2019,
  url     = {https://assets.nagios.com/downloads/general/docs/Monitoring_Architecture_Solutions_For_Large_Organizations.pdf},
  journal = {Nagios - monitoring architecture solutions for large organizations},
  year    = {2019}
} 


// Article 27
@inproceedings{desnoyers2006lttng,
  title        = {The lttng tracer: A low impact performance and behavior monitor for gnu/linux},
  author       = {Desnoyers, Mathieu and Dagenais, Michel R},
  booktitle    = {OLS (Ottawa Linux Symposium)},
  volume       = {2006},
  pages        = {209--224},
  year         = {2006},
  organization = {Citeseer}
}

// Article 28
@article{adhianto2010hpctoolkit,
  title     = {HPCToolkit: Tools for performance analysis of optimized parallel programs},
  author    = {Adhianto, Laksono and Banerjee, Sinchan and Fagan, Mike and Krentel, Mark and Marin, Gabriel and Mellor-Crummey, John and Tallent, Nathan R},
  journal   = {Concurrency and Computation: Practice and Experience},
  volume    = {22},
  number    = {6},
  pages     = {685--701},
  year      = {2010},
  publisher = {Wiley Online Library}
}

// Article 29
@misc{kernelPerfWiki,
  author       = {},
  title        = {{P}erf {W}iki --- perf.wiki.kernel.org},
  howpublished = {\url{https://perf.wiki.kernel.org/index.php/Main_Page}},
  year         = {2023},
  note         = {[Accessed 16-10-2023]}
}

// Article 30
@inproceedings{ilsche2015combining,
  title        = {Combining instrumentation and sampling for trace-based application performance analysis},
  author       = {Ilsche, Thomas and Schuchart, Joseph and Sch{\"o}ne, Robert and Hackenberg, Daniel},
  booktitle    = {Tools for High Performance Computing 2014: Proceedings of the 8th International Workshop on Parallel Tools for High Performance Computing, October 2014, HLRS, Stuttgart, Germany},
  pages        = {123--136},
  year         = {2015},
  organization = {Springer}
}

// Article 31
@misc{man7Perf,
  author       = {},
  title        = {perf\_event\_open(2) - {L}inux manual page --- man7.org},
  howpublished = {\url{https://man7.org/linux/man-pages/man2/perf_event_open.2.html}},
  year         = {},
  note         = {[Accessed 16-10-2023]}
}


// Article 32
@misc{sourceforgeAboutOProfile,
  author       = {},
  title        = {{A}bout {O}{P}rofile --- oprofile.sourceforge.io},
  howpublished = {\url{https://oprofile.sourceforge.io/about/}},
  year         = {},
  note         = {[Accessed 16-10-2023]}
}

// Article 33
@inproceedings{schone2014scalable,
  title        = {Scalable tools for non-intrusive performance debugging of parallel linux workloads},
  author       = {Sch{\"o}ne, Robert and Schuchart, Joseph and Ilsche, Thomas and Hackenberg, Daniel},
  year         = {2014},
  organization = {Ottawa Linux Symposium Comittee}
}

// Article 34
@article{prieur2018r,
  title     = {R-SHT: A state history tree with R-Tree properties for analysis and visualization of highly parallel system traces},
  author    = {Prieur-Drevon, Loic and Beamonte, Rapha{\"e}l and Dagenais, Michel R},
  journal   = {Journal of Systems and Software},
  volume    = {135},
  pages     = {55--68},
  year      = {2018},
  publisher = {Elsevier}
}

// Article 35
@article{chen2021distributed,
  title     = {Distributed architecture for an integrated development environment, large trace analysis, and visualization},
  author    = {Chen Kuang Piao, Yonni and Ezzati-Jivan, Naser and Dagenais, Michel R},
  journal   = {Sensors},
  volume    = {21},
  number    = {16},
  pages     = {5560},
  year      = {2021},
  publisher = {MDPI}
}


// Article 36

@misc{apptainerHome,
  author       = {},
  title        = {{H}ome --- apptainer.org},
  howpublished = {\url{https://apptainer.org/}},
  year         = {},
  note         = {[Accessed 16-10-2023]}
}

// Article 37

@misc{ansibleAnsibleSimple,
  author       = {Ansible, Red Hat},
  title        = {{A}nsible is {S}imple {I}{T} {A}utomation --- ansible.com},
  howpublished = {\url{https://www.ansible.com/}},
  year         = {},
  note         = {[Accessed 16-10-2023]}
}

// Article 38

@book{gregg2011dtrace,
  title     = {DTrace: Dynamic Tracing in Oracle Solaris, Mac OS X, and FreeBSD},
  author    = {Gregg, Brendan and Mauro, Jim},
  year      = {2011},
  publisher = {Prentice Hall Professional}
}

@manual{Ericsson_TSP_OPENAPI,
  author = {Ericsson},
  title  = {Trace server protocol openapi specification},
  url    = {https://raw.githubusercontent.com/theia-ide/trace-server-protocol/master/API.yaml}
}

@misc{github_ericsson_TSP,
  author       = {Ericsson},
  howpublished = {\url{https://raw.githubusercontent.com/theia-ide/trace-server-protocol/master/API.yaml}},
  title        = {Trace server protocol}
}

@inbook{Foundation,
  place  = {Toulouse},
  title  = {},
  author = {Foundation, Eclipse}
} 

@conference{theia_2017,
  author    = {Sven Efftinge, Anton Kosyakov},
  title     = {Theia - One IDE Framework For Desktop \& Cloud},
  month     = {June},
  booktitle = {EclipseCon France 2017},
  address   = {Toulouse, France},
  year      = {2017}
}

@inproceedings{Na_2020,
  author    = {Na, Heechang and You, Zhi-Qiang and Baer, Troy and Oottikkal, Shameema and Dockendorf, Trey and Brozell, Scott},
  booktitle = {2020 IEEE/ACM International Workshop on HPC User Support Tools (HUST) and Workshop on Programming and Performance Visualization Tools (ProTools)},
  title     = {HPC Software Tracking Strategies for a Diverse Workload},
  year      = {2020},
  volume    = {},
  number    = {},
  pages     = {1-9},
  doi       = {10.1109/HUSTProtools51951.2020.00008}
}

@inproceedings{Aggoune_2023,
  author    = {Aggoune, Aicha and Benratem, Zineb},
  booktitle = {2023 International Conference on Advances in Electronics, Control and Communication Systems (ICAECCS)},
  title     = {ECG Data Visualization: Combining the power of Grafana and InfluxDB},
  year      = {2023},
  volume    = {},
  number    = {},
  pages     = {1-6},
  doi       = {10.1109/ICAECCS56710.2023.10104857}
}


@article{do2021data,
  title  = {Data Visualization with Integration of Grafana and Quanta Platform},
  author = {Do, Bao Khanh},
  year   = {2021}
}

@inproceedings{Mix_2018,
  author    = {Mix, Hartmut and Herold, Christian and Weber, Matthias},
  booktitle = {2018 IEEE International Parallel and Distributed Processing Symposium Workshops (IPDPSW)},
  title     = {Visualization of Multi-layer I/O Performance in Vampir},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {387-394},
  doi       = {10.1109/IPDPSW.2018.00073}
}


@misc{GmbH_Vampir,
  title   = {Vampir - performance optimization},
  url     = {https://vampir.eu/},
  journal = {Overview},
  author  = {GmbH, GWT}
} 

@inproceedings{Martens_2010,
  author    = {Martens, Anne and Koziolek, Heiko and Becker, Steffen and Reussner, Ralf},
  title     = {Automatically Improve Software Architecture Models for Performance, Reliability, and Cost Using Evolutionary Algorithms},
  year      = {2010},
  isbn      = {9781605585635},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1712605.1712624},
  doi       = {10.1145/1712605.1712624},
  abstract  = {Quantitative prediction of quality properties (i.e. extra-functional properties such as performance, reliability, and cost) of software architectures during design supports a systematic software engineering approach. Designing architectures that exhibit a good trade-off between multiple quality criteria is hard, because even after a functional design has been created, many remaining degrees of freedom in the software architecture span a large, discontinuous design space. In current practice, software architects try to find solutions manually, which is time-consuming, can be error-prone and can lead to suboptimal designs. We propose an automated approach to search the design space for good solutions. Starting with a given initial architectural model, the approach iteratively modifies and evaluates architectural models. Our approach applies a multi-criteria genetic algorithm to software architectures modelled with the Palladio Component Model. It supports quantitative performance, reliability, and cost prediction and can be extended to other quantitative quality criteria of software architectures. We validate the applicability of our approach by applying it to an architecture model of a component-based business information system and analyse its quality criteria trade-offs by automatically investigating more than 1200 alternative design candidates.},
  booktitle = {Proceedings of the First Joint WOSP/SIPEW International Conference on Performance Engineering},
  pages     = {105-116},
  numpages  = {12},
  keywords  = {software architecture, cost, reliability, optimisation, quality attribute prediction, performance},
  location  = {San Jose, California, USA},
  series    = {WOSP/SIPEW '10}
}

@misc{Kolny_2023,
  title     = {Scaling up the Prime Video Audio/video monitoring service and reducing costs by 90%},
  url       = {https://www.primevideotech.com/video-streaming/scaling-up-the-prime-video-audio-video-monitoring-service-and-reducing-costs-by-90},
  journal   = {Prime Video Tech},
  publisher = {Prime Video Tech},
  author    = {Kolny, Marcin},
  year      = {2023},
  month     = {Mar}
} 

@misc{Terra_2023,
  title     = {What is client-server architecture? everything you should know: Simplilearn},
  url       = {https://www.simplilearn.com/what-is-client-server-architecture-article#:~:text=The%20client%2Dserver%20architecture%20refers,model%20or%20client%20server%20network.},
  journal   = {Simplilearn.com},
  publisher = {Simplilearn},
  author    = {Terra, John},
  year      = {2023},
  month     = {Aug}
} 

@book{Coulouris_2012,
  place     = {Harlow},
  title     = {Distributed systems: Concepts and design},
  publisher = {Addison-Wesley},
  author    = {Coulouris, George and Dollimore, Jean and Kinberg, Tim and Blair, Gordon},
  year      = {2012}
} 

@article{toole2006bittorrent,
  title     = {Bittorrent architecture and protocol},
  author    = {Toole, Ryan and Vokkarane, Vinod},
  journal   = {University of Massachusetts Dartmouth, Dartmouth},
  year      = {2006},
  publisher = {Citeseer}
}

@inbook{Vu2010,
  author    = {Vu, Quang Hieu
               and Lupu, Mihai
               and Ooi, Beng Chin},
  title     = {Architecture of Peer-to-Peer Systems},
  booktitle = {Peer-to-Peer Computing: Principles and Applications},
  year      = {2010},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {11--37},
  abstract  = {Chapter 2 presents various architectures of P2P systems. We first introduce a taxonomy of P2P architectures, where we classify P2P systems into three main categories: centralized P2P systems, decentralized P2P systems, and hybrid P2P systems. While centralized P2P systems are systems that are supported by centralized servers, decentralized P2P systems are pure P2P systems, which are completely decentralized. On the other hand, hybrid systems are systems where nodes are organized into two layers: the upper tier super nodes act as servers for lower tier nodes. After the introduction, for each of these P2P categories, we discuss in details its properties as well as outstanding P2P systems belonging to its category. In particular, for centralized P2P systems, we introduce Napster and SETI@home. For decentralized P2P systems, we present Gnutella, PAST, Canon, and Skip Graph. Finally, for hybrid P2P systems, we show BestPeer, a self-configurable P2P system.},
  isbn      = {978-3-642-03514-2},
  doi       = {10.1007/978-3-642-03514-2_2},
  url       = {https://doi.org/10.1007/978-3-642-03514-2_2}
}

@article{Abdella_2021,
  author  = {Abdella, Juhar and Tari, Zahir and Anwar, Adnan and Mahmood, Abdun and Han, Fengling},
  journal = {IEEE Transactions on Smart Grid},
  title   = {An Architecture and Performance Evaluation of Blockchain-Based Peer-to-Peer Energy Trading},
  year    = {2021},
  volume  = {12},
  number  = {4},
  pages   = {3364-3378},
  doi     = {10.1109/TSG.2021.3056147}
}

@article{castillo2011soap,
  title   = {SOAP vs REST: Comparing a master-slave GA implementation},
  author  = {Castillo, Pedro A and Bernier, Jose Luis and Arenas, Maribel Garcia and Merelo, JJ and Garcia-Sanchez, Pablo},
  journal = {arXiv preprint arXiv:1105.4978},
  year    = {2011}
}

@inproceedings{Liu_2010,
  author    = {Liu, Jiaqi and Ding, Ning and Xu, Jiangrong},
  booktitle = {2010 International Conference on Electrical and Control Engineering},
  title     = {The Research of the Double Master/Slave System Architecture in the MPI Parallel Environment},
  year      = {2010},
  volume    = {},
  number    = {},
  pages     = {3098-3101},
  doi       = {10.1109/iCECE.2010.755}
}


@article{LU2020106497,
  title    = {Parallel and distributed architecture of genetic algorithm on Apache Hadoop and Spark},
  journal  = {Applied Soft Computing},
  volume   = {95},
  pages    = {106497},
  year     = {2020},
  issn     = {1568-4946},
  doi      = {https://doi.org/10.1016/j.asoc.2020.106497},
  url      = {https://www.sciencedirect.com/science/article/pii/S1568494620304361},
  author   = {Hao-Chun Lu and F.J. Hwang and Yao-Huei Huang},
  keywords = {Genetic algorithm, Parallel and distributed computing, Traveling salesman problems, Apache Hadoop, Apache Spark},
  abstract = {The genetic algorithm (GA), one of the best-known metaheuristic algorithms, has been extensively utilized in various fields of management science, operational research, and industrial engineering. The efficiency of GAs in solving large-scale optimization problems would be enhanced if the iterative processes required by the genetic operators can be implemented in a parallel and distributed computing architecture. Apache Hadoop has recently been one of the most popular systems for distributed storage and parallel processing of big data. By integrating the GA highly into Apache Hadoop, this study proposes an advanced GA parallel and distributed computing architecture that achieves the effectiveness and efficiency of GA evolution. Characterized by the sophisticated mechanism of dispatching the GA core operators into Apache Hadoop, the developed computing framework fits well with the cloud computing model. The presented GA parallelization architecture outperforms the state-of-the-art reference architectures according to the computational experiments where the testing instances of traveling salesman problems are employed. Our numerical experiments also demonstrate that the proposed architecture can readily be extended to Apache Spark.}
}

@inproceedings{Vadlamani2021,
  author    = {Vadlamani, Sri Lakshmi and Emdon, Benjamin and Arts, Joshua and Baysal, Olga},
  booktitle = {2021 IEEE/ACM 8th International Workshop on Software Engineering Research and Industrial Practice (SER\&IP)},
  title     = {Can GraphQL Replace REST? A Study of Their Efficiency and Viability},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {10-17},
  doi       = {10.1109/SER-IP52554.2021.00009}
}

@mastersthesis{Piao2018,
  month    = {August},
  title    = {Nouvelle architecture pour les environnements de d{\'e}veloppement int{\'e}gr{\'e} et tra{\c c}age de logiciel},
  school   = {{\'E}cole Polytechnique de Montr{\'e}al},
  author   = {Yonni Chen Kuang Piao},
  year     = {2018},
  url      = {https://publications.polymtl.ca/3282/},
  abstract = {R{\'E}SUM{\'E}: La conception et le d{\'e}veloppement de logiciels requi{\`e}rent souvent l'utilisation d'un Environnement de D{\'e}veloppement Int{\'e}gr{\'e} (EDI) pour assister et faciliter le travail des d{\'e}veloppeurs. Les EDI offrent, {\`a} travers une interface graphique, des outils pour l'{\'e}dition, la compilation et le d{\'e}bogage du code. Cependant, lorsque ces outils ne sont pas adapt{\'e}s et suffisants pour la d{\'e}tection de d{\'e}fauts de performance sur des logiciels complexes, comme les syst{\`e}mes distribu{\'e}s, les d{\'e}veloppeurs se tournent vers des techniques de tra{\c c}age. Des logiciels appel{\'e}s traceurs r{\'e}coltent des informations pr{\'e}cises pendant l'ex{\'e}cution du syst{\`e}me instrument{\'e}, et les regroupent dans une trace. Une trace peut contenir une quantit{\'e} importante de donn{\'e}es. Des outils sp{\'e}cialis{\'e}s ont {\'e}t{\'e} d{\'e}velopp{\'e}s afin d'en automatiser le processus d'analyse et de visualisation. Au fur et {\`a} mesure qu'un logiciel grandit et se complexifie, l'utilisation de ces outils d'analyse et de visualisation devient tout aussi importante qu'un d{\'e}bogueur. N{\'e}anmoins, ces outils sont complexes, autonomes et difficilement r{\'e}utilisables dans d'autres syst{\`e}mes. De plus, ils ne supportent pas les m{\^e}mes analyses, les m{\^e}mes formats de trace, ni les m{\^e}mes cas d'utilisation, ce qui implique que le d{\'e}veloppeur ait besoin d'installer plusieurs outils pour arriver {\`a} ses fins. Dans le cadre de ce projet, nous cherchons donc {\`a} r{\'e}soudre ces probl{\`e}mes et {\`a} int{\'e}grer l'analyse et la visualisation de trace non seulement dans les EDI, mais dans tout autre syst{\`e}me qui pourrait en b{\'e}n{\'e}ficier, tels que les serveurs d'int{\'e}gration continue ou encore les syst{\`e}mes de monitorage. Par cons{\'e}quent, nous proposons une nouvelle architecture logicielle flexible bas{\'e}e sur une approche client-serveur, d'architecture orient{\'e}e service et multicouche. Notre travail s'{\'e}tend {\`a} l'impl{\'e}mentation de l'architecture du serveur au sein du projet Trace Compass et l'impl{\'e}mentation de l'architecture du client au sein d'un nouveau projet appel{\'e} TraceScape. Toutes nos contributions sont disponibles {\`a} code source ouvert. Des tests de performance ont {\'e}t{\'e} men{\'e}s afin d'{\'e}valuer le surco{\^u}t associ{\'e} {\`a} la nouvelle architecture par rapport {\`a} la pr{\'e}c{\'e}dente approche, et les r{\'e}sultats indiquent un surco{\^u}t acceptable.  ABSTRACT: Creating software often requires using an Integrated Development Environment (IDE) to help and facilitate the development work. With a simplified user interface, IDEs provide many useful tools such as a code editor, a compiler, and a debugger. Nonetheless, when those tools are not enough to detect performance defects in a large, complex and multithreaded system, developers use tracing techniques. A program called tracer collects accurate information during the execution of an instrumented system. A trace could contain a lot of data, and specialized tools have been developed to analyze traces automatically and show the results in interactive views. As the software grows and becomes more complex, using trace visualization tools must be part of the developer tool environment, like the debugger in the software development process. However, trace visualization tools are sophisticated, standalone and hardly reusable in other systems such as an IDE. Moreover, they have their specific trace format support, specific use cases, and specific trace analyses. Most of the time, developers need to install and use several such tools to fulfill their needs. In this research project, we aim to solve those problems and integrate trace analysis and visualization in tools such as IDEs, monitoring systems or continuous integration systems. Thus, we propose a flexible software architecture based on client-server, service-oriented architecture and layered approaches. We implemented the server architecture in the Trace Compass project and the client architecture in a new project called TraceScape. All of our contributions are available online in open source repositories. We also evaluated our proposed architecture through benchmarks, and the results show that our approach has an acceptable overhead compared to the standalone approach.}
}

@book{fielding2000architectural,
  title     = {Architectural styles and the design of network-based software architectures},
  author    = {Fielding, Roy Thomas},
  year      = {2000},
  publisher = {University of California, Irvine}
}


@misc{Johnson2022,
  title   = {What is rest},
  url     = {https://restfulapi.net/},
  journal = {REST API Tutorial},
  author  = {Johnson, Brad Andrew and Gupta, Lokesh and Ravan and Admin and Jay and Person and Young, Dave and Packer, Jason and Choudhary, Chandrajeet and Luis and et al.},
  year    = {2022},
  month   = {Apr}
}

@misc{RESTChap5,
  url     = {https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm},
  journal = {Fielding Dissertation: CHAPTER 5: Representational State Transfer (REST)}
} 

@inproceedings{guo2018design,
  title        = {Design and implementation of real-time management system architecture based on GraphQL},
  author       = {Guo, Ying and Deng, Fang and Yang, Xiudong},
  booktitle    = {IOP Conference Series: Materials Science and Engineering},
  volume       = {466},
  number       = {1},
  pages        = {012015},
  year         = {2018},
  organization = {IOP Publishing}
}

@inproceedings{Brito2019,
  author    = {Brito, Gleison and Mombach, Thais and Valente, Marco Tulio},
  booktitle = {2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  title     = {Migrating to GraphQL: A Practical Assessment},
  year      = {2019},
  volume    = {},
  number    = {},
  pages     = {140-150},
  doi       = {10.1109/SANER.2019.8667986}
}

@inproceedings{Brito,
  author    = {Brito, Gleison and Mombach, Thais and Valente, Marco Tulio},
  booktitle = {2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  title     = {Migrating to GraphQL: A Practical Assessment},
  year      = {2019},
  volume    = {},
  number    = {},
  pages     = {140-150},
  doi       = {10.1109/SANER.2019.8667986}
}

@inproceedings{Hartina2018,
  author    = {Hartina, Dewi Ayu and Lawi, Armin and Panggabean, Benny Leonard Enrico},
  booktitle = {2018 2nd East Indonesia Conference on Computer and Information Technology (EIConCIT)},
  title     = {Performance Analysis of GraphQL and RESTful in SIM LP2M of the Hasanuddin University},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {237-240},
  doi       = {10.1109/EIConCIT.2018.8878524}
}

@inproceedings{Lee2020,
  author    = {Lee, Eunggi and Kwon, Kiwoong and Yun, Jungmee},
  booktitle = {2020 International Conference on Information and Communication Technology Convergence (ICTC)},
  title     = {Performance Measurement of GraphQL API in Home ESS Data Server},
  year      = {2020},
  volume    = {},
  number    = {},
  pages     = {1929-1931},
  doi       = {10.1109/ICTC49870.2020.9289569}
}


@inproceedings{Sayago2020,
  author    = {Sayago Heredia, Jaime
               and Flores-Garc{\'i}a, Evelin
               and Solano, Andres Recalde},
  editor    = {Botto-Tobar, Miguel
               and Zambrano Vizuete, Marcelo
               and Torres-Carri{\'o}n, Pablo
               and Montes Le{\'o}n, Sergio
               and Pizarro V{\'a}squez, Guillermo
               and Durakovic, Benjamin},
  title     = {Comparative Analysis Between Standards Oriented to Web Services: SOAP, REST and GRAPHQL},
  booktitle = {Applied Technologies},
  year      = {2020},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {286--300},
  abstract  = {The use of web services has increased and has become the most widely used implementation today. The most crucial part of a web development project is the choice of the right tools for application development, this decision significantly influences the requirements to implement solutions for these services. The comparative analysis between SOAP, REST and GraphQL web services aims to assess the effectiveness of data transfer capabilities. The methods used were a systematic mapping to define the metrics to use for comparison such as response time and performance. A test environment was implemented, starting with the development of a web application using each of the technologies to be evaluated and in different programming languages. Then, the performance of web services was tested with the defined metrics and tools. We found, from experimental tests, that GraphQL has a faster response time and better performance than web services based on SOAP and REST. The result of the comparison can help developers choose the optimal and appropriate technology based on the performance of web services and other metrics that influence an essential aspect such as software quality.},
  isbn      = {978-3-030-42517-3}
}

@article{hartig2017initial,
  title     = {An initial analysis of Facebook's GraphQL language},
  author    = {Hartig, Olaf and P{\'e}rez, Jorge},
  year      = {2017},
  publisher = {CEUR-WS}
}

@misc{GraphQLLearn,
  url     = {https://graphql.org/learn/},
  journal = {GraphQL}
} 


@inproceedings{hartig2018semantics,
  title     = {Semantics and complexity of GraphQL},
  author    = {Hartig, Olaf and P{\'e}rez, Jorge},
  booktitle = {Proceedings of the 2018 World Wide Web Conference},
  pages     = {1155--1164},
  year      = {2018}
}

@inproceedings{wittern2018generating,
  title        = {Generating graphql-wrappers for rest (-like) apis},
  author       = {Wittern, Erik and Cha, Alan and Laredo, Jim A},
  booktitle    = {International Conference on Web Engineering},
  pages        = {65--83},
  year         = {2018},
  organization = {Springer}
}

@inproceedings{vargas2018deviation,
  title     = {Deviation testing: A test case generation technique for graphql apis},
  author    = {Vargas, Daniela Meneses and Blanco, Alison Fernandez and Vidaurre, Andreina Cota and Alcocer, Juan Pablo Sandoval and Torres, Milton Mamani and Bergel, Alexandre and Ducasse, St{\'e}phane},
  booktitle = {11th International Workshop on Smalltalk Technologies (IWST)},
  pages     = {1--9},
  year      = {2018}
}

@inproceedings{wittern2019empirical,
  title        = {An empirical study of GraphQL schemas},
  author       = {Wittern, Erik and Cha, Alan and Davis, James C and Baudart, Guillaume and Mandel, Louis},
  booktitle    = {Service-Oriented Computing: 17th International Conference, ICSOC 2019, Toulouse, France, October 28--31, 2019, Proceedings 17},
  pages        = {3--19},
  year         = {2019},
  organization = {Springer}
}

@article{kiraly2018analysing,
  title   = {Analysing RPC and testing the performance of solutions},
  author  = {Kiraly, Sandor and Szekely, Szilveszter},
  journal = {Informatica},
  volume  = {42},
  number  = {4},
  year    = {2018}
}

@misc{JsonRpcSpec,
  url     = {https://www.jsonrpc.org/specification},
  journal = {JSON}
} 
